Как легко работать с IPTables.

	Одним из наиболее мощных и востребованных функций ОС Linux, является сочетание двух встроенных инструментов IPTables/Netfilter. Модули Netfilter, как правило, уже встроены в ядро в современных поставках различных дистрибутивов Linux и их редко когда требуется устанавливать дополнительно. Проект IPTables является управляющей настройкой для Netfilter, и после него похожих проектов появилось изрядное количество (UFW, Shorewall, firewalld, etc) и поэтому иногда его требуется до устанавливать. В большинстве случаев, это частный вопрос идущий от идеологии команды производителя дистрибутива, и чаще всего IPTables либо уже есть в поставке, либо просто до устанавливается из основного репозитория. Дополнительно к iptables существует изрядное количество модулей и пакетов, которые расширают возможности по настройке фильтрации, и так же пакеты со скриптами, позволяющие более-менее быстро и предсказуемо генерировать конфигурацию для управления поведением Netfilter.
	Но, всё же, что бы понимать, что генерировать и оценивать готовность итогового скрипта с настройками, лучше понимать, что сама система может. А ещё вернее, уметь выполнять эту настройку самостоятельно и без дополнительных инструментов-прокладок.

CHAINS:
	Изначально, сама концепция управления трафиком посредством IPTables/Netfilter (дальше просто IPTables) достаточно проста. Есть основные направления INPUT/OUTPUT/FORWARD, которые характеризуют с какой стороны и куда трафик заходит на интерфейсы хоста, и то, как хост их отрабатывает в соответствии с правилами настройки, помещёнными в файл
  /etc/sysconfig/iptables.
	Правила комбинируются в последовательности, которые с давних пор принято называть цепочками (CHAINS).
	Основными цепочками являются INPUT, OUTPUT, FORWARD. В INPUT заходит трафик преимущественно для интерфейсов хоста, в OUTPUT попадает трафик исходящий с интерфейсов хоста, от служб (отвечающий на запросы) или непосредственно из пользовательского пространства. В FORWARD помещается транзитный трафик сетей обслуживаемых хостом при включенной пересылке пакетов между интерфейсами в /etc/sysctl.conf (для ОС ALTLinux это /etc/net/sysctl.conf) узла.

TABLES:
	Цепочки объединены в таблицы, которых пять:
RAW — используется только для настройки пакетов, поэтому они освобождаются от отслеживания.
MANGLE — используется для специальных преобразований пакетов.
NAT — используется для преобразования сетевых адресов (например, проброс портов).
FILTER — таблица по умолчанию; в ней сосредоточены все действия, типичные для межсетевых экранов.
SECURITY — используется в сетевых правилах для Мандатного управления доступом (например, в SELinux или ).
	Чаще всего, требуются только две из них: FILTER и NAT;
RAW и MANGLE более специфичны для маршрутизаторов или для серверов приложений;
SECURITY работа с этой таблицей выполняется при использовании SELinux, или для фильтрации по mac-адресам, и тп.
Взаимоотношения TABLES и CHAINS можно понять по данной диаграмме:
https://www.frozentux.net/iptables-tutorial/chunkyhtml/images/tables_traverse.jpg

POLICIES:
	FILTER — таблица по умолчанию, исходя из выполненных нами установок, IPTables знает, что делать с пакетами трафика по шагам, сверху вниз по правилам помещённым в скрипт настройки. И выполняет заданные к отфильтрованному трафику действия характеризуемые целями (targets). Цель ACCEPT — пропускает, DPOP — молча отбрасывает, REJECT — отбрасывает и сообщает обратно о своём действии с пакетами отправившему их хосту.
	Дополнительно, существует правило по умолчанию к порядку такой обработки в финале пропуска пакета; тогда когда он уже прощёл все правила, найдя или не найдя для себя установку что делать. Такое правило определяется политикой, и она может быть ACCEPT/DROP/REJECT.
В зависимости от назначения хоста, и глубины понимания его назначения, могут быть выбраны разные политики по работе с трафиком. Например, политику ACCEPT удобно применять для лабораторных сред, или для внутресетевых маршрутизаторов; REJECT логично использовать для внутренних сетей, или для сред виртуализации, для повышения качества обслуживания, или соблюдения соглашений. Политику DROP -- логично использовать на границе сетей, для снижения рисков различного вида нарушений (атак), для улучшения качества работы вверенной нам сети, ну и для соблюдения сетевого этикета.

TARGETS:
	Помимо линейного прохождения пакетов по цепочкам, могут быть реализованы инструменты для более сложного управления
потоком трафика. Такой подход реализуется через применение целей расширения, или пользовательских цепочек. Существующие в большинстве конфигураций встроенные цели — ACCEPT, DROP, REJECT, используются чаше всего, и являются завершающими прохождение пакета, т.е. выполняется предписанное действие и прекращается идущая сверху вниз по цепочке обработка входящего пакета. Если пакет дошёл до конца цепочки, и не получил цели, то он сопровождается в соответствии с указанной политикой, т. е. в большинстве случаев, отбрасывается.
	Цели-расширения могут быть завершающими (как встроенные) или незавершающими (как пользовательские цепочки).
	Цели-расширения, к примеру QUEUE, RETURN, LOG, NETMAP выполняют дополнительные действия по обработке пакета. Они могут завершить его обработку, или продолжить, всё зависит от типа и назначения цели.

USER CHAINS:
	Так же, могут быть использованы и реализованы дополнительные цели, т.н. USER CHAINS и пересылка пакета в них. Если в качестве цели выбран переход в пользовательскую цепочку, то пакет проходя через неё, после возвращается в исходную цепочку и продолжает со следующего после перехода правила. Ко всему, пользовательскую цепочку можно сделать завершающей, указав встроенную цель, или же перенаправить пакеты в другую пользовательскую цепочку.

NAT TABLE:
	Из других, наиболее типичных цепочек, существуют способы для работы с маскированными через NAT сетями. Для работы с SNAT (исходящий трафик сети, как правило (таблица NAT)) -- используется цепочка POSTROUTING. Для работы с DNAT (доступ к опубликованным наружу сервисам (так же таблица NAT) используется цепочка PREROUTING. IPTables работает отдельно с таблицей фильтрации и таблицей NAT, и по умолчанию использует в командах -t filter. Что бы указать правило в таблице NAT нужно её указать прямым образом.

RAW, MANGLE, SECURITY:
	Существуют так же реже используемые, но так же очень важные цепочки, это RAW, MANGLE, SECURITY. Вместе или по отдельности, они служат для увеличения безопасности работы нашего маршрутизатора с приходящим, или проходящим через него трафиком:
	RAW — позволяет выполнять обработку пакетов на ранней стадии, до попадания в цепочку INPUT или в FORWARD, и это
снижает загрузку маршрутизатора, или внутренних клиентов, и позволяет снижать воздействие различных DoS манипуляций, что так же улучшает доступность и безопасность нашей сети и Интернет.
	MANGLE — позволяет менять характеристики пакетов; например, менять TTL пакета.
	SECURITY — специальная цепочка, служащая для пере направления трафика в систему мандатного управления SELinux (или
другую, когда она есть). Так же, к примеру, через неё реализуется работа с фильтрацией от узлов по mac-адресу.
	Предполагается, что таблицы RAW, MANGLE, SECURITY используются при детальном понимании стека протокола TCP/IP.

	В итоге, мы коротко рассмотрели общие концепции работы с Netfilter через IPTables, и их возможности по управлению сетевым трафиком на основе хоста с ОС Linux.  Стоит заметить, что применение правил можно реализовать на основе 3-5-10-строчной конфигурации, что достаточно удобно, быстро, и не требует большого и длительного вникания в сущности управления сетевым устройством. Достаточно посетить два-три сайта с примерами применения IPTables, и возникает ощущение простоты и доступности
использования. Например, вот эти:
https://www.thegeekstuff.com/2011/06/iptables-rules-examples/
https://linuxconfig.org/collection-of-basic-linux-firewall-iptables-rules/
	Но это достаточно быстро проходит, т.к. основные вопросы возникают по мере работы с этим инструментом.
Вопросы такие как:
  — как сделать более понятной работу с более комплексной конфигурацией?
  — как сделать конфигурацию более переносимой и универсальной?
  — как реализовать более гибкое управление потоком данных?
  — как осуществлять запись событий в логи, и как их сортировать?
  — как избежать переполнения пространства выделенного под запись событий?
  — как реализовать простейшие функции системы обнаружения вторжений, и более-менее про активного реагирования на
 стандартные методы воздействия потенциальных злоумышленников?

	Для наращивания возможностей выделенного нам файрволла, стоит осмыслить и применять несколько правил.
  — не настраивать файрволл в другом городе, если у вас нет доступа с iLO сервера, не выполнены минимальные
подготовительные настройки. Доступ к iLO сервера, позволит вам выполнить перезапуск системы, если вы потеряли к ней доступ
вследствие ошибки в настройке. В ОС RedHat и в ОС ALTLinux, настройки правил IPTables сохраняются в файл конфигурации в
/etc/sysconfig/iptables, и при перезапуске сервера, они будут подгружены сервисом iptables.service. Т.о., если в
/etc/sysconfig/iptables содержатся более-менее корректные правила, проверенные по доступности, и закрывающие одновременно
сеть и систему, то достаточно перезапустить устройство, виртуальную машину или сам сервис, и правила будут восстановлены.
Да, но... надо суметь перезапустить сервис.
  Сохранение корректных правил, которым мы доверяем, выполняется посредство такой вот команды:
  iptables-save > /etc/sysconfig/iptables -- она выполняет сохранения в файл правил.
  Обратное действие, восстановление, производится обратной командой:
  iptables-restore < /etc/sysconfig/iptables
  Если выполняем долгую комплексную настройку в ситуации без протестированных правил, возможностей и с неопределённостями.
Например, такое возможно в условиях с низкой надёжностью канала. Тогда можно придумать скрипт восстановления конфигурации,
который запускать через crond с более-менее удобным интервалом. Вот простой пример такого скрипта:
===============================================================
#!/bin/bash
# reset.fw - Reset firewall
# set x to 0 - No reset
# set x to 1 - Reset firewall
# =============================================================
# Before testing use
# /sbin/iptables-save > /root/scripts/iptables-save-rules.fw
# chmod +x  /root/scripts/iptables-save-rules.fw
x=1

# set method
METHOD=first
# METHOD=second
# METHOD=third

### no need to edit below  ###
IPT=/sbin/iptables
IPT6=/sbin/ip6tables

if [ "$x" == "1" ];
then
	if [ "$METHOD" == "first" ];
	then
	# reset firewall using redhat script
	/etc/init.d/iptables stop
	/etc/init.d/ip6tables stop
	/sbin/iptables-restore < /root/scripts/iptables-save-rules.fw
	/etc/init.d/iptables start
	else
		# for all other Linux distro use following rules to reset firewall
		### reset ipv4 iptales ###
		$IPT -F
		$IPT -X
		$IPT -Z
		for table in $(</proc/net/ip_tables_names)
		do
			$IPT -t $table -F
			$IPT -t $table -X
			$IPT -t $table -Z
		done
		$IPT -P INPUT ACCEPT
		$IPT -P OUTPUT ACCEPT
		$IPT -P FORWARD ACCEPT
		### reset ipv6 iptales ###
		$IPT6 -F
		$IPT6 -X
		$IPT6 -Z
		for table in $(</proc/net/ip6_tables_names)
		do
			$IPT6 -t $table -F
			$IPT6 -t $table -X
			$IPT6 -t $table -Z
		done
		$IPT6 -P INPUT ACCEPT
		$IPT6 -P OUTPUT ACCEPT
		$IPT6 -P FORWARD ACCEPT
#                  iptables -F
#                  iptables -X
#                  iptables -Z
#                  iptables -t mangle -F
#                  iptables -t mangle -X
#                  iptables -t mangle -Z
#                  iptables -t nat -F
#                  iptables -t nat -X
#                  iptables -t nat -Z
#                  iptables -t raw -F
#                  iptables -t raw -X
#                  iptables -t raw -Z
#  add this later

	fi
else
        :
fi
===============================================================


он позволяет по таймеру выполнить восстановление отдельно сохранённой конфигурации IPTables, в случае потери доступа.
Ведь порой лучше подождать минут 20, чем ехать в другой город, или будить смену поддержки.

	Для выполнения настройки сетевого фильтра, важен более-менее системный подход, и поэтапная реализация шагов связанных
с настройкой IPTables.

СБРОС ПРАВИЛ.
Сбросить правила iptables можно следующими командами:

# iptables -F
# iptables -X
# iptables -t nat -F
# iptables -t nat -X
# iptables -t mangle -F
# iptables -t mangle -X
# iptables -t raw -F
# iptables -t raw -X
# iptables -t security -F
# iptables -t security -X
# iptables -P INPUT ACCEPT
# iptables -P FORWARD ACCEPT
# iptables -P OUTPUT ACCEPT

	Как правило, это бывает необходимо во время первоначальной настройки, или же при использовании более комплексного
порядка настройки IPTables, а так же когда ничего не ясно, и лучше уже настроить с нуля. Однако, даже для этой задачи стоит написать небольшой скрипт, что бы упростить себе решение.

	Полезно держать требуемые инструменты в доступной версии Git (GitLab, GitHub), либо поднимать свою версию с настройками  из контейнера Docker и публиковать её в сети. Возможно, кому-то будет проще просто отправка по SSH на удалённый хост набора вот таких команд:

# Простейшая подготовка к настройке сетевого фильтра
# Подразумевается, наличие в системе пакетов:iptables,iptables-save.
#

#0.
[root@slinux ~]# mkdir -p /etc/sysconfig/_iptables
[root@slinux ~]# cd /etc/sysconfig/_iptables
[root@slinux _iptables]# pwd
/etc/sysconfig/_iptables
[root@slinux _iptables]# touch _1-IPT-flash-script.sh && chmod +x _1-IPT-flash-script.sh
[root@slinux _iptables]# touch _2-IPT-base-script.sh && chmod +x _2-IPT-base-script.sh
[root@slinux _iptables]# touch _3-IPT-setup-script.sh && chmod +x _3-IPT-setup-script.sh
[root@slinux _iptables]# touch _4-IPT-debug-stateful-script.sh && chmod +x _4-IPT-debug-stateful-script.sh
[root@slinux _iptables]# touch _5-IPT-debug-stateless-script.sh && chmod +x _5-IPT-debug-stateless-script.sh
[root@slinux _iptables]# touch _6-IPT-debug-server-services-script.sh && chmod +x _6-IPT-debug-server-services-script.sh

[root@slinux _iptables]# ls -la
итого 16
drwxr-xr-x 2 root root 4096 мая 18 18:33 .
drwxr-xr-x 6 root root 4096 мая 17 23:16 ..
-rwxr-xr-x 1 root root  995 мая 18 11:46 _1-IPT-flash-script.sh
-rwxr-xr-x 1 root root 1713 мая 18 11:46 _2-IPT-base-script.sh
-rwxr-xr-x 1 root root    0 мая 17 23:19 _3-IPT-setup-script.sh

#1.
cat > _1-IPT-flash-script.sh <<<'#!/bin/bash
#=========================================================================================================
# Flash all chains and rules and setup ACCEPT ALL policies
#=========================================================================================================
#
# Reset All Rules
#
iptables -F
iptables -X
iptables -Z
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X
iptables -t raw -F
iptables -t raw -X
iptables --flush
iptables --table nat --flush
iptables --delete-chain
iptables --table nat --delete-chain
#
iptables -P INPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -P OUTPUT ACCEPT
#=======================================================================================================
echo "Firewall completely stopped! WARNING: THIS HOST HAS NO FIREWALL RUNNING!"
#=======================================================================================================
'

TO THIS LINE=============================================================================================

#2.
cat > _2-IPT-base-script.sh <<<'#!/bin/bash
#========================================================================================================
# Simple rules for basic iptables setup.
#========================================================================================================

iptables -P INPUT ACCEPT
iptables -P OUTPUT ACCEPT
iptables -P FORWARD ACCEPT

iptables -A INPUT -p ALL -i lo --source 127.0.0.1 --destination 127.0.0.1 -j ACCEPT
iptables -A OUTPUT -p ALL -o lo --source 127.0.0.1 --destination 127.0.0.1 -j ACCEPT

iptables -A INPUT -p tcp -i enp0s9 --dport 22 --source 192.168.192.100 --destination 192.168.92.105 -j ACCEPT
iptables -A OUTPUT -p tcp -o enp0s9 --sport 22 --source 192.168.92.105 --destination 192.168.192.100 -j ACCEPT

iptables -t nat -A POSTROUTING -s 192.168.120.0/24 -d 0/0 -o enp0s9 -j SNAT --to-source 192.168.92.105
iptables -t nat -A POSTROUTING -s 192.168.110.0/24 -d 0/0 -o enp0s9 -j SNAT --to-source 192.168.92.105

iptables -A FORWARD -i enp0s8 -o enp0s9 -s 192.168.120.0/24 -j ACCEPT
iptables -A FORWARD -i enp0s10 -o enp0s9 -s 192.168.110.0/24 -j ACCEPT

iptables -A FORWARD -i enp0s9 -o enp0s8 -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A FORWARD -i enp0s9 -o enp0s10 -m state --state ESTABLISHED,RELATED -j ACCEPT
#================================================================================================
echo "Firewall works with simple rules! WARNING: BE CAREFUL!"
#================================================================================================
'

TO THIS LINE====================================================================================

	В итоге, мы можем получить три скрипта для выполнения базовых установок для IPTables.
	1. _1-IPT-flash-script.sh -- когда всё открыто, правила минимальные и всё разрешают. Можно добавлять требуемые правила.
	2. _2-IPT-base-script.sh -- выполнена минимальная настройка SNAT, разрешены исходящие пакеты из внутренней сети, и разрешены подключения к порту SSH маршрутизатора. Все остальные подключения так же разрешены, поскольку включена политика ACCEPT
iptables -P INPUT ACCEPT
iptables -P OUTPUT ACCEPT
iptables -P FORWARD ACCEPT

	3. _3-IPT-setup-script.sh — задача скрипта выполнить подготовку к настройке маршрутизатора и предоставить возможность
 выполнять наращивание функций управления.
	Предполагается, что этому способствуют:
1. секционирование групп правил, и комментирование,
2. наличие примитивной схемы подключения, выполненной псевдографикой (может быть полезно при передаче работ),
3. наличие раздела с документированием информации по модулям ядра, и по параметрам установленным в /etc/sysctl.conf,
4. наличие группы с предустановленными параметрами для работы с настройками, которую можно расширять по мере осознания потребностей,
5. выделенная группа макросов для создания пользовательских цепочек,
6. отдельные правила для разрешённого трафика localhost, и для правил соединений с устновленными соединениями,
7. отдельные правила для белого листа с разрешённым внешним хостом, для гарантированной реализации внешнего подключения,
8. предустановленная политика DROP на цепочках INPUT, OUTPUT, FORWARD,
9. настроенная политика SNAT, то есть внутренние узлы могут подкючаться в сеть за NAT (Интернет, или что-то иное),
10. набор проверенных правил являющихся основанием для включения функции IDS в работающую конфигурацию по мере потребности. Необходимость их подключения определяется условиями задачи, но в большинстве случаев, они могут и должны применяться для ограничения потенциальных нарушений на внешнем интерфейсе файрволла.

1. Секции самые простые, лишь бы sh не ругался.
2. Примитивная схемка в заголовке позволит не сломать голову, не забыть адреса, и дать возможность быстрее разобраться с идеей коллегам.
3. Позволяет не забыть,  что, где и как включать, что бы реализовать правильную настройку:
4. Список макросов параметризации достаточно велик, и может быть продолжен:
5. Список пользовательских цепочек. Их оказалось удобнее создавать и описывать централизованно.
6. Разрешённый трафик для интерфейса loopback.
8. Политика DROP, что бы не тратить время на лишние шаги.
7.Служат для предоставления возможности удалённо отладить скрипт файрволла.
Реализованы разрешённые подключения с адреса прописанного в макросе SSH_CLI1 по SSH, и проверка доступности средствами PING и TRACEROUTE.
6. В зависимости от представления, можно задачу определять тремя правилами, или же более дискретно.
Пример реализации пользовательской цепочки для пакетов с установленным соединением.
9.Использование SNAT и POSTROUTING.
10.Правила очистки трафика приходящего на WAN-интерфейс, для цепочек INPUT и FORWARD.
11.Шаблон правила для выполнения дальнейшей настройки.

Полный предустановочный скрипт доступен по ссылке:
https://github.com/it-engineer-pro/FireWalling/blob/main/3.IPTables-Netfilter/etc/sysconfig/_iptables/_3-IPT-setup-script.sh

Полностью сейчас и в дальнейшем, работу можно будет увидеть по ссылке:
https://github.com/it-engineer-pro/FireWalling.git
использование идеи, клонирование и использование в работе на ваше усмотрение.

ССЫЛКИ:
https://habr.com/en/articles/585238/
https://wiki.archlinux.org/title/Simple_stateful_firewall_(Русский)/
https://www.thegeekstuff.com/2011/06/iptables-rules-examples/
https://linuxconfig.org/collection-of-basic-linux-firewall-iptables-rules/
https://www.frozentux.net/iptables-tutorial/chunkyhtml/images/tables_traverse.jpg
https://man.archlinux.org/man/iptables-extensions.8
